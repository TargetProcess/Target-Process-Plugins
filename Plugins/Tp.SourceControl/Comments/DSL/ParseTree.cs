// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;
using StructureMap;
using Tp.SourceControl.Comments;
using Tp.SourceControl.Comments.DSL;
using Tp.SourceControl.Messages;

namespace TinyPG
{
	#region ParseTree
	[Serializable]
	public class ParseErrors : List<ParseError>
	{
	}

	[Serializable]
	public class ParseError
	{
		private string message;
		private int code;
		private int line;
		private int col;
		private int pos;
		private int length;

		public int Code { get { return code; } }
		public int Line { get { return line; } }
		public int Column { get { return col; } }
		public int Position { get { return pos; } }
		public int Length { get { return length; } }
		public string Message { get { return message; } }

		// just for the sake of serialization
		public ParseError()
		{
		}

		public ParseError(string message, int code, ParseNode node) : this(message, code,  0, node.Token.StartPos, node.Token.StartPos, node.Token.Length)
		{
		}

		public ParseError(string message, int code, int line, int col, int pos, int length)
		{
			this.message = message;
			this.code = code;
			this.line = line;
			this.col = col;
			this.pos = pos;
			this.length = length;
		}
	}

	// rootlevel of the node tree
	[Serializable]
	public partial class ParseTree : ParseNode
	{
		public ParseErrors Errors;

		public List<Token> Skipped;

		public ParseTree() : base(new Token(), "ParseTree")
		{
			Token.Type = TokenType.Start;
			Token.Text = "Root";
			Errors = new ParseErrors();
		}

		public string PrintTree()
		{
			StringBuilder sb = new StringBuilder();
			int indent = 0;
			PrintNode(sb, this, indent);
			return sb.ToString();
		}

		private void PrintNode(StringBuilder sb, ParseNode node, int indent)
		{
			
			string space = "".PadLeft(indent, ' ');

			sb.Append(space);
			sb.AppendLine(node.Text);

			foreach (ParseNode n in node.Nodes)
				PrintNode(sb, n, indent + 2);
		}

		public object Eval(params object[] array)
		{
			return Eval(new Evaluator());
		}
		

		public object Eval(Evaluator evaluator)
		{
			Nodes[0].Evaluator = evaluator;
			return Nodes[0].Eval();
		}
	}

	[Serializable]
	[XmlInclude(typeof(ParseTree))]
	public partial class ParseNode
	{
		protected string text;
		protected List<ParseNode> nodes;
		
		public List<ParseNode> Nodes { get {return nodes;} }
		
		[XmlIgnore] // avoid circular references when serializing
		public ParseNode Parent;
		public Token Token; // the token/rule

		[XmlIgnore] // skip redundant text (is part of Token)
		public string Text { // text to display in parse tree 
			get { return text;} 
			set { text = value; }
		} 

		Evaluator _evaluator;
		public Evaluator Evaluator
		{
			get { return _evaluator; }
			set { _evaluator = value; }
		}

		public virtual ParseNode CreateNode(Token token, string text)
		{
			ParseNode node = new ParseNode(token, text);
			node.Parent = this;
			return node;
		}

		protected ParseNode(Token token, string text)
		{
			this.Token = token;
			this.text = text;
			this.nodes = new List<ParseNode>();
		}

		public object this[TokenType type]
		{
			get
			{
				return GetValue(type, 0);
			}
		}
		
		public object this[TokenType type, int index]
		{
			get
			{
				return GetValue(type, index);
			}
		}
		
		protected object GetValue(TokenType type, int index)
		{
			return GetValue(type, ref index);
		}

		protected object GetValue(TokenType type, ref int index)
		{
			object o = null;
			if (index < 0) return o;

			// left to right
			foreach (ParseNode node in nodes)
			{
				if (node.Token.Type == type)
				{
					index--;
					if (index < 0)
					{
						node.Evaluator = _evaluator;
						o = node.Eval();
						break;
					}
				}
			}
			return o;
		}

		/// <summary>
		/// this implements the evaluation functionality, cannot be used directly
		/// </summary>
		/// <param name="tree">the parsetree itself</param>
		/// <param name="paramlist">optional input parameters</param>
		/// <returns>a partial result of the evaluation</returns>
		internal object Eval()
		{
			object Value = null;

			switch (Token.Type)
			{

	case TokenType.Start:
		Value = _evaluator.EvalStart(this);
	break;

	case TokenType.ActionNode:
		Value = _evaluator.EvalActionNode(this);
	break;

	case TokenType.EntityIdClause:
		Value = _evaluator.EvalEntityIdClause(this);
	break;

	case TokenType.PostTimeClause:
		Value = _evaluator.EvalPostTimeClause(this);
	break;

	case TokenType.ChangeStatusClause:
		Value = _evaluator.EvalChangeStatusClause(this);
	break;

	case TokenType.PostCommentClause:
		Value = _evaluator.EvalPostCommentClause(this);
	break;

				default:
					Value = Token.Text;
					break;
			}
			return Value;
		}

	}
	
	#endregion ParseTree
	
	
	public class Evaluator 
	{

		public virtual object EvalStart(ParseNode node)
		{
			            var result = new List<AssignRevisionToEntityAction>();
        	int i = 0;
        	while(node[TokenType.ActionNode, i] != null)
        	{
        		result.AddRange(node[TokenType.ActionNode, i] as List<AssignRevisionToEntityAction>);
        		i++;
        	}
        
        	return result;
		}

		public virtual object EvalActionNode(ParseNode node)
		{
			            var result = new List<AssignRevisionToEntityAction>();
        	int i = 0;
        	while (node[TokenType.EntityIdClause, i] != null)
        	{
        		result.Add(node[TokenType.EntityIdClause, i] as AssignRevisionToEntityAction);
        		i++;
        	}
        	var childActions = new List<IAction>();
        	i = 0;
        	while (node[TokenType.PostTimeClause, i] != null)
        	{
        		childActions.Add(node[TokenType.PostTimeClause, i] as IAction);
        		i++;
        	}
        	i = 0;
        	while (node[TokenType.PostCommentClause, i] != null)
        	{
        		childActions.Add(node[TokenType.PostCommentClause, i] as IAction);
        		i++;
        	}
        	i = 0;
        	while (node[TokenType.ChangeStatusClause, i] != null)
        	{
        		childActions.Add(node[TokenType.ChangeStatusClause, i] as IAction);
        		i++;
        	}
        
        	foreach (var action in result)
        	{
        		action.Children.AddRange(childActions);
        	}
        
        	return result;
		}

		public virtual object EvalEntityIdClause(ParseNode node)
		{
			            return ObjectFactory.GetInstance<IActionFactory>().CreateAssignRevisionToEntityAction(NodeParser.GetEntityId(node[TokenType.NUMBER, 0]));
		}

		public virtual object EvalPostTimeClause(ParseNode node)
		{
			            decimal? timeLeft = null;
        	if (node[TokenType.DECIMAL, 1] != null)
        	{
        		timeLeft = NodeParser.GetTime(node[TokenType.DECIMAL, 1]);
        	}
        	return ObjectFactory.GetInstance<IActionFactory>().CreatePostTimeAction(NodeParser.GetTime(node[TokenType.DECIMAL, 0]), timeLeft);
		}

		public virtual object EvalChangeStatusClause(ParseNode node)
		{
			            return ObjectFactory.GetInstance<IActionFactory>().CreateChangeStatusAction(NodeParser.GetStatus(node[TokenType.ANY_TEXT, 0]));
		}

		public virtual object EvalPostCommentClause(ParseNode node)
		{
			            int i = 0;
        	StringBuilder result = new StringBuilder();
        	while (node[TokenType.ANY_TEXT, i] != null)
        	{
        		result.AppendLine(NodeParser.GetCommentSegment(node[TokenType.ANY_TEXT, i]));
        		i++;
        	}
        	if(result.Length > Environment.NewLine.Length)
        	{
        		result.Remove(result.Length - Environment.NewLine.Length, Environment.NewLine.Length);
        	}
        	
        	return ObjectFactory.GetInstance<IActionFactory>().CreatePostCommentAction(result.ToString());
		}

	}
}




/* 
<%Symbol%>
	case TokenType.<%Name%>:
		Value = _evaluator.Eval<%Name%>(this);
	break;
<%Symbol%>

<%Method%>
		public virtual object Eval<%Name%>(ParseNode node)
		{
			<%Code%>
		}
<%Method%>

<%DefaultMethodBody%>			return null;<%DefaultMethodBody%>

<%TokenAccessor%>node[TokenType.<%Name%>, <%Index%>]<%TokenAccessor%>
*/
